<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Unit-Testing on Nikos Voulgaris</title>
        <link>//localhost:1313/tags/unit-testing/</link>
        <description>Recent content in Unit-Testing on Nikos Voulgaris</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <copyright>Nikos Voulgaris</copyright>
        <lastBuildDate>Mon, 27 Aug 2018 00:00:00 +0000</lastBuildDate><atom:link href="//localhost:1313/tags/unit-testing/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>How much code coverage should I have?</title>
        <link>//localhost:1313/how-much-code-coverage-should-i-have/</link>
        <pubDate>Mon, 27 Aug 2018 00:00:00 +0000</pubDate>
        
        <guid>//localhost:1313/how-much-code-coverage-should-i-have/</guid>
        <description>&lt;img src="//localhost:1313/img/posts/code_coverage.jpg" alt="Featured image of post How much code coverage should I have?" /&gt;&lt;p&gt;One of the most disturbing questions I often get refers to the percentage of the code that should be covered by unit tests. This is a perfectly fine question coming from a fairly inexperienced developer, but it troubles me greatly in virtually any other case. However, what urged me to write this post is that I gradually become aware of more and more organizations that actually impose rules on this metric. Rules like &amp;ldquo;the project &lt;em&gt;must&lt;/em&gt; have 90% code coverage&amp;rdquo;.&lt;/p&gt;
&lt;p&gt;Now, there is a number of issues with this kind of approach. What if we get a 99% code coverage and we keep on getting bugs regularly? Does this 99% reflect code quality? Is it wise to impose rules on the developers, forcing them to reach a certain number on the metric? Can one write a suite of tests that cover all the code, but essentially test &lt;em&gt;nothing&lt;/em&gt;? Is this meaningful? and more importantly, &lt;strong&gt;why&lt;/strong&gt; are we testing in the first place?&lt;/p&gt;
&lt;p&gt;Before we delve into the topic, let me clarify the following: practicing TDD as a discipline means that code coverage should approach 100% (but never quite reach it actually). However, since this post does not refer only to TDDers and even applying TDD won&amp;rsquo;t result in a 100% code coverage (one can easily understand this taking into consideration configuration files, Data Transfer Objects etc), I would like to take a more pragmatic view and discuss on the mentality behind all these.&lt;/p&gt;
&lt;h2 id=&#34;example&#34;&gt;
    &lt;a href=&#34;#example&#34;&gt;#&lt;/a&gt;
    Example
&lt;/h2&gt;&lt;p&gt;Allow me to begin with an example that will help us understand the nature of the problem in hand. Let&amp;rsquo;s consider the following, very simplistic function that performs division between two integers (it&amp;rsquo;s hardly reasonable to assume that anyone would need such a function, but let&amp;rsquo;s consider it for the sake of the argument).&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;divide&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; a, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; b) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; a &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; b;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;How many tests should we write for this function? Which tests should these be? It&amp;rsquo;s fairly obvious that a single test would result in a 100% code coverage for this one-liner. Is this sufficient? Now let&amp;rsquo;s take a step back and reflect for a moment.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;How many states can this piece of code be in?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;A state would be a = 1 and b = 1. A second state would be a = 1 and b = 2 and so forth. Therefore, the combinations of all the possible values of variables &lt;code&gt;a&lt;/code&gt; (the numerator) and &lt;code&gt;b&lt;/code&gt; (the denominator) gives us the answer. Assuming that &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are both java integers, each can take a bit over 4 billion values. Therefore, the states that this piece of code can be in are 4.000.000.000 squared!&lt;/p&gt;
&lt;p&gt;Hopefully, by now, my point is illustrated. &lt;em&gt;It&amp;rsquo;s very easy to reach 100% code coverage and yet, we have tested only 1 out of 4.000.000.000 squared states&lt;/em&gt;.&lt;/p&gt;
&lt;h2 id=&#34;meaningful-testing&#34;&gt;
    &lt;a href=&#34;#meaningful-testing&#34;&gt;#&lt;/a&gt;
    Meaningful testing
&lt;/h2&gt;&lt;p&gt;Having understood the problem, what should one do? Opt for trying to test each and every state is clearly not only insanity, but very wasteful too. On the other hand, staying rest assured with the impressing 100% code coverage, created by the first test, is clearly not the right option either, since, clearly, a very problematic set of states remain untested: the ones when &lt;code&gt;b&lt;/code&gt; (the denominator) is equal to 0.&lt;/p&gt;
&lt;p&gt;Enter on of the most important virtues of unit testing: &lt;em&gt;meaningfulness&lt;/em&gt;. Coming back to the previously asked questions, I believe that testing a couple &amp;ldquo;regular&amp;rdquo; cases and one with the denominator equal to 0 (I guess, expecting an &lt;code&gt;ArithmeticException&lt;/code&gt; to be thrown) makes sense and is probably what most software engineers would do.&lt;/p&gt;
&lt;p&gt;However, consider our choice of tests. Can anyone actually &lt;em&gt;prove&lt;/em&gt; that these tests suffice to cover this piece of code? Is there a &lt;em&gt;mathematical formula&lt;/em&gt; that can produce this set of tests as the &lt;em&gt;right&lt;/em&gt; answer to the question of how many and which tests should we write? Absolutely &lt;strong&gt;no&lt;/strong&gt;. Can it be the case that we were actually careless and have missed a bug after all? Absolutely &lt;strong&gt;yes&lt;/strong&gt;. This is nothing more than a &lt;em&gt;sensible&lt;/em&gt; result, a &lt;strong&gt;meaningful&lt;/strong&gt; suite of tests for this piece of code.&lt;/p&gt;
&lt;p&gt;Of course, this example, being very simplistic, leaves almost no room for error. However, one can understand that in real world situations the margin for error is significantly increased and being meaningful in choosing the test cases takes a whole lot more importance. However, meaningful testing is not a quality some developers are born with and some other are destined to never possess. It&amp;rsquo;s mainly built through trial and error and derives from experience. So, perhaps, next time you face a bug, take a moment to think why it wasn&amp;rsquo;t covered with a unit test in the first place (by the way, also never forget to add that unit test, but this is another topic).&lt;/p&gt;
&lt;h2 id=&#34;avoid-meaningless-tests&#34;&gt;
    &lt;a href=&#34;#avoid-meaningless-tests&#34;&gt;#&lt;/a&gt;
    Avoid meaningless tests
&lt;/h2&gt;&lt;p&gt;Quite often, the very constraint on a code coverage number can be very harmful. People tend to forget &lt;em&gt;why&lt;/em&gt; are they testing and start writing tests just to satisfy the numbers. Junior developers get the wrong stimulae, which shape their careers in the wrong way.&lt;/p&gt;
&lt;p&gt;Meaningless tests, tests that test &lt;em&gt;nothing&lt;/em&gt; become part of the regression suite, polluting the project in a unique way. They may &lt;em&gt;fail frequently&lt;/em&gt;, causing the developers to &lt;em&gt;ignore&lt;/em&gt; them, causing a total lack of trust in the test suite, or, even worse, they may be &lt;em&gt;green all the time&lt;/em&gt;, even when a defect is introduced to the system. In either way, credibility in the test suite is lost, refactoring becomes harder and harder and eventually the project rots.&lt;/p&gt;
&lt;h2 id=&#34;follow-the-trend&#34;&gt;
    &lt;a href=&#34;#follow-the-trend&#34;&gt;#&lt;/a&gt;
    Follow the trend
&lt;/h2&gt;&lt;p&gt;Coming back to the situations where organizations enforce specific code coverage numbers - I hope that by now the fundamental problems that lie with this approach have become apparent - what would a sensible policy be? We&amp;rsquo;re not actually suggesting that code coverage is totally useless, right? Of course not. On the contrary, it can be immensely valuable.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;How should it be used then?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This constitutes ground for experimentation and I would very much like to hear anyone&amp;rsquo;s views on the matter. For now, let me describe an approach that I find useful. Start monitoring the code coverage and create a trend line metric for it. Make sure that, before merging a merge request, the line does not drop. If it does so, kindly ask the author to amend this, before merging the code. This can even constitute a condition in the team&amp;rsquo;s DoD. I believe that a lot of CI tools will provide plug-ins that help implement this policy (personally, I have used Jenkins and JaCoCo).&lt;/p&gt;
&lt;h2 id=&#34;untested-code&#34;&gt;
    &lt;a href=&#34;#untested-code&#34;&gt;#&lt;/a&gt;
    Untested code
&lt;/h2&gt;&lt;p&gt;Instead of missing the point and start chasing after numbers just for the sake of it, use code coverage as what it really is: a &lt;em&gt;tool&lt;/em&gt;. Make sure you go thoroughly over the report (tools like JaCoCo produce an extremely detailed report) on a regular basis. This can point out quite a few interesting things, such as untested parts of the code. Identify them and act on them. Perhaps a pattern will become visible. Find the problem and address it.&lt;/p&gt;
&lt;h2 id=&#34;quality-testing&#34;&gt;
    &lt;a href=&#34;#quality-testing&#34;&gt;#&lt;/a&gt;
    Quality testing
&lt;/h2&gt;&lt;p&gt;Getting fixated on the code coverage number will harm both the developers and the project they&amp;rsquo;re working on in the long run. Instead of it, try to create a culture that focuses on quality testing. Make sure that the right tests are being written, the engineers start to gradually &lt;strong&gt;trust&lt;/strong&gt; their test suite, enabling them to refactor the code as often as they find useful and bugs that slip into production become less and less. At all times, remember that:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Low code coverage means that there are problems. High code coverage means nothing at all on its own.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;conclusion&#34;&gt;
    &lt;a href=&#34;#conclusion&#34;&gt;#&lt;/a&gt;
    Conclusion
&lt;/h2&gt;&lt;p&gt;Code coverage is a great &lt;strong&gt;tool&lt;/strong&gt;, but use it wisely. Stay clear from useless, arbitrary rules and constraints. Oppose yourself to them, no matter who imposed them, with grounds. Raise the coverage as high as possible, but as a result of responsible, meaningful, quality testing and think hard on any poorly tested (or even untested) areas. Focus on the ability to &lt;strong&gt;refactor using tests as a safety net&lt;/strong&gt; and &lt;strong&gt;catching bugs&lt;/strong&gt; as early as possible. As always, forget about the rules. Stick to the essence.&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Test behavior</title>
        <link>//localhost:1313/test-behavior/</link>
        <pubDate>Wed, 23 May 2018 00:00:00 +0000</pubDate>
        
        <guid>//localhost:1313/test-behavior/</guid>
        <description>&lt;img src="//localhost:1313/img/posts/writing.jpg" alt="Featured image of post Test behavior" /&gt;&lt;p&gt;Over the years, I have identified a number of issues with the way most companies treat their tests. I have come to believe that the most important one is that test code is treated as a second class citizen. Developers usually opt for the cheap, quick-and-dirty solutions when it comes to writing (or maintaining) tests, not realizing their importance. However, test code has to be &lt;em&gt;designed&lt;/em&gt;, &lt;em&gt;reviewed&lt;/em&gt; and &lt;em&gt;refactored&lt;/em&gt;, exactly like production code. What we usually fail to realize is that the way we write tests reflects on the &lt;em&gt;quality&lt;/em&gt; of our production code, allows &lt;em&gt;bugs&lt;/em&gt; to creep in and drives &lt;em&gt;design&lt;/em&gt; decisions.&lt;/p&gt;
&lt;h2 id=&#34;two-approaches&#34;&gt;
    &lt;a href=&#34;#two-approaches&#34;&gt;#&lt;/a&gt;
    Two approaches
&lt;/h2&gt;&lt;p&gt;In this post I will delve into the topic of &lt;em&gt;testing behavior&lt;/em&gt; as opposed to &lt;em&gt;testing implementation&lt;/em&gt;. So, let&amp;rsquo;s elaborate a bit on these two fundamentally different styles. When testing behavior, we&amp;rsquo;re thinking:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;I want to verify that, under these circumstances, the result of an action is this&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Testing for state on the other hand, means thinking:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;I want to verify that, under these circumstances, these actions take place to reach to the result&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Obviously, the approach is utterly different, but the gold is to understand the consequences of following one or the other. Before we work the trade-offs, let&amp;rsquo;s illustrate the two styles via a simplified example.&lt;/p&gt;
&lt;h2 id=&#34;example&#34;&gt;
    &lt;a href=&#34;#example&#34;&gt;#&lt;/a&gt;
    Example
&lt;/h2&gt;&lt;p&gt;Assuming we have a unit that fetches all employees from the database, calculates their average salary and sends an e-mail with this number on the subject line. A &lt;em&gt;test-implementation&lt;/em&gt; logic could lead us to verify that the number of the fetched employees is correct by asserting on the size of a list data structure, the correct employees with the correct salaries are retrieved, the average salary is correct after taking into account each employee etc.&lt;/p&gt;
&lt;p&gt;On the other hand, a &lt;em&gt;test-behavior&lt;/em&gt; mentality would probably result in executing the method and checking that the &lt;code&gt;send()&lt;/code&gt; method was executed in the e-mail service collaborator with the correct argument for the &lt;code&gt;subject&lt;/code&gt; parameter.&lt;/p&gt;
&lt;h2 id=&#34;trade-offs&#34;&gt;
    &lt;a href=&#34;#trade-offs&#34;&gt;#&lt;/a&gt;
    Trade-offs
&lt;/h2&gt;&lt;p&gt;We should always keep in mind that when it comes to software engineering, there is no silver bullet. A great part of our job is to recognize the trade-offs when they present themselves and decide responsibly, living with the consequences. Having said this, both approaches would work, leading to - most probably - different implementations and different ramifications when it comes to flexibility and maintenance.&lt;/p&gt;
&lt;h3 id=&#34;refactoring&#34;&gt;
    &lt;a href=&#34;#refactoring&#34;&gt;#&lt;/a&gt;
    Refactoring
&lt;/h3&gt;&lt;p&gt;One of the most common pitfalls is to couple too tight our tests with the production code. What would happen in the first approach (test-implementation) when, in the future we decide to dump the list and use a different data structure? Our test (that asserts on the list size and contents) will fail to compile. We will be forced to refactor the test along with the production code, immediately jeopardizing our whole refactoring process. Let me elaborate on this topic.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;When refactoring a piece of code, we intend to alter its structure but &lt;strong&gt;not&lt;/strong&gt; its behavior.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;In order to do so, given that the result of any action under the same circumstances remains unaffected, we should be able to rely on our tests to know that we did not change the behavior indeed. However, if we modify our tests, we run the risk of unwittingly modifying what we&amp;rsquo;re testing, allowing bugs to creep in the production code.&lt;/p&gt;
&lt;p&gt;We may stay clear from this danger applying the &lt;em&gt;test-behavior&lt;/em&gt; logic. In this case, the tests do not &lt;em&gt;&amp;ldquo;see&amp;rdquo;&lt;/em&gt; the actual implementation and since the results of the actions remain unchanged, the tests remain unaffected and we can make sure we keep them green in each and every refactoring move we make.&lt;/p&gt;
&lt;h3 id=&#34;ripple-effects&#34;&gt;
    &lt;a href=&#34;#ripple-effects&#34;&gt;#&lt;/a&gt;
    Ripple effects
&lt;/h3&gt;&lt;p&gt;In my blog post on &lt;a class=&#34;link&#34; href=&#34;https://nvoulgaris.com/unit-testing-best-practices&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;unit testing best practices&lt;/a&gt; I referred to &lt;em&gt;isolation&lt;/em&gt; as key property of unit tests. I stated that if a test fails, &lt;em&gt;&amp;ldquo;it should clearly declare a single aspect of the software that is not functioning properly and point us to it immediately&amp;rdquo;&lt;/em&gt;. In this post I was referring to leaving the system in the state that we found it, but the isolation principle may be violated in other ways too.&lt;/p&gt;
&lt;p&gt;When testing the implementation, we usually instantiate all the collaborators (dependencies) of the class we&amp;rsquo;re testing, whereas, when testing the behavior we tend to use &lt;strong&gt;test doubles&lt;/strong&gt;. A side effect of this is that if a bug lies in a collaborator of the class under test, its tests will remain unaffected in the latter approach, but will fail in the former, creating a &lt;strong&gt;ripple of failing tests&lt;/strong&gt;. Among other things, this will lead us into a debugging session in order to understand what is wrong with the system (as opposed to a finger pointing to the - carefully chosen - name of the failing test).&lt;/p&gt;
&lt;h3 id=&#34;design-decisions&#34;&gt;
    &lt;a href=&#34;#design-decisions&#34;&gt;#&lt;/a&gt;
    Design decisions
&lt;/h3&gt;&lt;p&gt;As I have mentioned earlier in this post, &lt;em&gt;tests drive design decisions&lt;/em&gt;. This is an immensely important point, so let me repeat it. &lt;em&gt;Tests shape our production code&lt;/em&gt;. I am mostly referring to Test Driven Development here, but we should always refactor a piece of code that is difficult to test, irrelevant of &lt;em&gt;when&lt;/em&gt; the tests where written. Therefore, the tests affect the production code even if we don&amp;rsquo;t test-drive it.&lt;/p&gt;
&lt;p&gt;Before we elaborate, let&amp;rsquo;s tale a step back to consider a basic unit testing tool: &lt;strong&gt;test doubles&lt;/strong&gt;. &lt;a class=&#34;link&#34; href=&#34;https://www.goodreads.com/author/show/193408.Gerard_Meszaros&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Gerard Meszaros&lt;/a&gt; uses this term to describe &lt;em&gt;an object that is used in place of a real object for testing purposes&lt;/em&gt;. Two test double types that we&amp;rsquo;re particularly interested in (for the purposes of this post) are the following:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Stub&lt;/strong&gt;: In advance specified behavior covering &lt;em&gt;specific answers to specific calls&lt;/em&gt;. This is done in order to serve the test and no additional behavior is prescribed.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Mock&lt;/strong&gt;: Specified &lt;em&gt;expectations&lt;/em&gt; referring on the &lt;em&gt;reception of specific method calls&lt;/em&gt; (potentially with specific arguments)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Now, these two different test doubles are mainly used by two different schools of thought.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Classical TDDers&lt;/strong&gt; will use &lt;em&gt;real instances of every collaborator&lt;/em&gt; involved in the test. When this is either inconvenient or too difficult, a test double will be used, usually a &lt;strong&gt;stub&lt;/strong&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Mockist TDDers&lt;/strong&gt; will &lt;em&gt;never instantiate another class&lt;/em&gt; besides the one which is under test. &lt;strong&gt;Mocks&lt;/strong&gt; will be used instead.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These choices are utterly important. It is easy to understand that the more stubs we use, the more we couple our unit tests with our production code. This happens because, what we&amp;rsquo;re essentially saying when stubbing a class is &lt;em&gt;&amp;ldquo;when this method is called with these arguments, do this&amp;rdquo;&lt;/em&gt;. However, this method call is an implementation detail and should we wish to not call this method during a future refactoring, our unit test will fail (or at least will have to be refactored as well, in order to remove the unused stubbing).&lt;/p&gt;
&lt;p&gt;In addition, a mockist TDDer will (via the usage of mocks instead of real objects) achieve a quite better (ideally perfect) isolation on the unit tests, as opposed to a classical TDDer, who will have to face a ripple of failing tests sooner or later.&lt;/p&gt;
&lt;p&gt;One of the most important aspects of this topic though is that different choices (stubs instead of mocks, classical TDD instead of mockist TDD) will result in a totally different production code and a totally different code design. Therefore, &lt;strong&gt;favoring testing behavior will produce a totally different application&lt;/strong&gt;, with different trade-offs, different advantages and shortcomings and different code quality. Hence, I believe that it has become apparent by now (if it wasn&amp;rsquo;t already) that these are decisions that we have to thinking very carefully and take very seriously.&lt;/p&gt;
&lt;h2 id=&#34;conclusion&#34;&gt;
    &lt;a href=&#34;#conclusion&#34;&gt;#&lt;/a&gt;
    Conclusion
&lt;/h2&gt;&lt;p&gt;My initial intention behind this blog post was to raise awareness. Test code should &lt;strong&gt;not&lt;/strong&gt; be treated as second class citizen. There are loads of crossroads, decisions and trade-offs out there and I hope that I have made clear that the ramifications are very significant. Favoring testing behavior brings along a series of side effects and in any case, it is a road that, should we decide to follow it, we should do so wittingly and with professionalism.&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Unit testing best practices</title>
        <link>//localhost:1313/unit-testing-best-practices/</link>
        <pubDate>Sat, 10 Feb 2018 00:00:00 +0000</pubDate>
        
        <guid>//localhost:1313/unit-testing-best-practices/</guid>
        <description>&lt;img src="//localhost:1313/img/posts/test_board.jpg" alt="Featured image of post Unit testing best practices" /&gt;&lt;p&gt;As part of the onboarding process of every new developer in &lt;a class=&#34;link&#34; href=&#34;http://www.tripsta.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Tripsta&lt;/a&gt;, I am required to deliver a training on unit testing basics. I would like to share the most valuable techniques, methodologies and best practices that I have collected over the years. I believe that they constitute the pillars of a solid foundation that every developer should have.&lt;/p&gt;
&lt;p&gt;It may be a bit unconventional (the way I love it), but before we even start, let me clarify the two most important things that tests &lt;strong&gt;are not&lt;/strong&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Tests are not nice to have&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Tests are not negotiable&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;When I hear phrases like &lt;em&gt;&amp;ldquo;If we have time, we&amp;rsquo;ll write some tests too&amp;rdquo;&lt;/em&gt; or &lt;em&gt;&amp;ldquo;It costs 13 story points, but since there is no time, we can  make it 8 if we don&amp;rsquo;t write tests&amp;rdquo;&lt;/em&gt; I want to quit my job and sell greengrocery for a living. Tests should be an integral part of writing software.&lt;/p&gt;
&lt;p&gt;I could use a lot of lines talking about the necessity of writing unit tests, the benefits they provide and how they should be an integral part of the software development process instead of just a verification layer (&lt;em&gt;hint: TDD&lt;/em&gt;),  but that is another blog post on its own. So, let&amp;rsquo;s delve into a handful of best practices which I have come to value over the years.&lt;/p&gt;
&lt;h2 id=&#34;best-practices&#34;&gt;
    &lt;a href=&#34;#best-practices&#34;&gt;#&lt;/a&gt;
    Best practices
&lt;/h2&gt;&lt;h3 id=&#34;naming&#34;&gt;
    &lt;a href=&#34;#naming&#34;&gt;#&lt;/a&gt;
    Naming
&lt;/h3&gt;&lt;p&gt;Some people are bad at naming. Some other (such as me) are terrible at it. In any case, taking the time to come up with a proper name for everything in our code &lt;em&gt;is worth it&lt;/em&gt;. Regardless of how much time we need. Uncle Bob (Robert Martin) likes to say &lt;em&gt;&amp;ldquo;with code, we do more reading than writing, by a huge factor. Which of those operations should be made efficient?&amp;rdquo;&lt;/em&gt; Naming &lt;strong&gt;matters&lt;/strong&gt;!! If I were to give you a single piece of advice on naming, it would be the following:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Write the tests you&amp;rsquo;d want to read&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Before stop writing a test and moving to the production code, ask yourself these two questions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Does the test clearly express its behavior?&lt;/li&gt;
&lt;li&gt;Is it easy to understand?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Usually, a developer that struggles to come up with a proper name will settle for a mediocre one, that does not express behavior properly, or even a bad one, which is hard to understand and misleads its reader.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Tests should be a documentation of the module&amp;rsquo;s behavior?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Whenever we come across a piece of code that we did not write, we want to be able to read its test suite and figure out what this piece of code does. So, take the time (however much you need) to name your tests (and the variables and functions in them) as best as you can and when you come across a mediocre or a bad name, &lt;em&gt;change it to something better&lt;/em&gt; (leaving the code cleaner than you found it, as Uncle Bob would say).&lt;/p&gt;
&lt;p&gt;Also, keep in mind that things change and, especially in the world of computer science, they do so rapidly. There is nothing wrong in starting off with a technique and shifting to a new one when you identify benefits to it. For instance, my team and I worked on a greenfield project almost a year ago and initially adopted the following naming convention:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;AccountTest&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;@Test&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;account_shouldStoreADepositTransaction_whenGivenOne&lt;/span&gt;() &lt;span style=&#34;color:#66d9ef&#34;&gt;throws&lt;/span&gt; Exception {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// Implementation&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This is a very common naming convention. However, after attending a Sandro Mancuso workshop, I was introduced to the following, far better approach, the benefits of which I presented to my team and we shifted to it.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;AccountShould&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;@Test&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;storeADepositTransaction&lt;/span&gt;() &lt;span style=&#34;color:#66d9ef&#34;&gt;throws&lt;/span&gt; Exception {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// Implementation&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;So, my advice is to be restless. Scan our (rich) community over the Internet and do not be afraid to shift to new practices and techniques so long as you recognize the value they offer.&lt;/p&gt;
&lt;h3 id=&#34;isolation&#34;&gt;
    &lt;a href=&#34;#isolation&#34;&gt;#&lt;/a&gt;
    Isolation
&lt;/h3&gt;&lt;p&gt;This whole point I want to make on isolation can be summarized in the following sentence:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Tests should leave the system in the state that they found it&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The last thing that we would like to face is 10 failing tests as a result of a single failure that dragged the following 9 tests with it. When we see x tests failing, we should know that there are exactly x problems with the system. Whenever a test is failing, it should clearly declare a single aspect of the software that is not functioning properly and point us to it immediately (by its name and the failure).&lt;/p&gt;
&lt;p&gt;In order to achieve this, we should ensure that our test, even when it fails, will restore the system to the exact situation it found it and it won&amp;rsquo;t leave it dirty. Each test should not know and care if another one run before it (let alone if it failed or not).&lt;/p&gt;
&lt;h3 id=&#34;watch-the-test-fail&#34;&gt;
    &lt;a href=&#34;#watch-the-test-fail&#34;&gt;#&lt;/a&gt;
    Watch the test fail
&lt;/h3&gt;&lt;p&gt;When should we stop writing the test and start writing the production code? That is a surprisingly hard to answer question for a lot of people when I give the training. Take a minute and think about it before reading further on. There are a couple of questions I like asking myself before I stop writing the test.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Does it fail for the right reason?&lt;/strong&gt; What good is a test if it does not break when the functionality breaks? How can we know that this won&amp;rsquo;t happen if we do not watch the test fail and make sure that it fails for the &lt;em&gt;right reason&lt;/em&gt;?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Are the diagnostics clear?&lt;/strong&gt; There will come a time in the future that this test will break and then someone (most probably us) will have to understand what is wrong and fix it. How hard will it be to fix it if we cannot tell what is wrong? A few months ago, I fell into exactly this pitfall, a test that I had written (quite a few months back) failed against the production code that I had written and all I had in the console was:&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Expected: 1
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Got: 0
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;I forced myself in a debugging session to figure out what was wrong. If only I had taken the time to make the diagnostics clear enough&amp;hellip;&lt;/p&gt;
&lt;h3 id=&#34;triple-a&#34;&gt;
    &lt;a href=&#34;#triple-a&#34;&gt;#&lt;/a&gt;
    Triple A
&lt;/h3&gt;&lt;p&gt;When it comes to designing our unit tests, I strongly recommend that the backbone of the structure should be based on &lt;em&gt;Arrange - Act - Assert&lt;/em&gt; (aka AAA). This is a very simple yet solid technique, consisting of the following three steps:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Arrange&lt;/strong&gt;: Initially, we should prepare the system for the upcoming test, making sure that all preconditions are met.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Act&lt;/strong&gt;: Then we should trigger the part of the code that we wish to test.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Assert&lt;/strong&gt;: Finally, we should evaluate whether the code meets our expectations or not. This is the point in which a flag should be raised, declaring the outcome of the test and this flag should either be green or red (no yellow or orange results - more on this on the &lt;em&gt;single assertion&lt;/em&gt; section).&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Let&amp;rsquo;s consider the following example (&lt;em&gt;I like using a blank line between the three steps, to make the code  more readable&lt;/em&gt;):&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@Test&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;validatorShouldThrowExceptionWhenBookingIDIsNull&lt;/span&gt;() &lt;span style=&#34;color:#66d9ef&#34;&gt;throws&lt;/span&gt; Exception {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  Booking booking &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; BookingBuilder.&lt;span style=&#34;color:#a6e22e&#34;&gt;aBooking&lt;/span&gt;().&lt;span style=&#34;color:#a6e22e&#34;&gt;withBookingId&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;).&lt;span style=&#34;color:#a6e22e&#34;&gt;build&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  Executable validateBooking &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; () &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; bookingValidator.&lt;span style=&#34;color:#a6e22e&#34;&gt;validate&lt;/span&gt;(booking);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  assertThrows(ValidationException.&lt;span style=&#34;color:#a6e22e&#34;&gt;class&lt;/span&gt;, validateBooking);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;We want to test that a &lt;code&gt;Validator&lt;/code&gt; class will throw an exception when validating a booking with null booking ID. In order to achieve this, we need a booking, which has a null booking ID. Given that we have it, we should execute the &lt;code&gt;validate(booking)&lt;/code&gt; method, which is the part of the code we wish to verify its functionality. Finally, we want to have a way to know if the code behaved in the expected way (threw a &lt;code&gt;ValidationException&lt;/code&gt;), so we write an assertion to expect exactly this.&lt;/p&gt;
&lt;p&gt;Some of the highlight benefits I find in this approach are the following:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;It promotes a &lt;em&gt;clear separation&lt;/em&gt; among the setup, execute and verification steps.&lt;/li&gt;
&lt;li&gt;A reader who is familiar with this technique can &lt;em&gt;understand the test fast&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Code smells&lt;/em&gt; in the test become easier to spot (e.g. a series of &lt;em&gt;act-assert&lt;/em&gt; steps - more on this on the &lt;em&gt;single assertion&lt;/em&gt; section)&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Discourages overengineering&lt;/em&gt; a test by focusing on the the absolutely needed steps to write it.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;single-assertion&#34;&gt;
    &lt;a href=&#34;#single-assertion&#34;&gt;#&lt;/a&gt;
    Single assertion
&lt;/h3&gt;&lt;p&gt;How many assertions should a test have? The answer should always be &lt;em&gt;one&lt;/em&gt;. What message is a red bar sending to us? That something is wrong in the system. Which is our reflex move? To find out what is this. This is exactly why we want our tests to be shouting out loud the reason for their failure. If a test fails, we should know, just by reading its name, what the problem is. How can this happen if a test fails for multiple reasons though?&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Unit tests should fail for one and only one reason&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Watch out for a common misconception though. The following test, contains two assertions. Does it violate the single assertion rule?&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@Test&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;calculatorShouldGeneratePositiveEvenIntegers&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; number &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; calculator.&lt;span style=&#34;color:#a6e22e&#34;&gt;generate&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  assertThat(number &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; 0).&lt;span style=&#34;color:#a6e22e&#34;&gt;isTrue&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  assertThat(number &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; 2).&lt;span style=&#34;color:#a6e22e&#34;&gt;isEqualTo&lt;/span&gt;(0);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;There may be two &lt;em&gt;physical&lt;/em&gt; assertions, but they essentially constitute a single &lt;em&gt;logical&lt;/em&gt; assertion. This test will fail &lt;em&gt;if and only if the calculator does not generate positive even numbers&lt;/em&gt;, as opposed to the following test:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@Test&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;calculatorShouldDivideNumbers&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; number &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; calculator.&lt;span style=&#34;color:#a6e22e&#34;&gt;divide&lt;/span&gt;(2, 2);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  assertThat(number).&lt;span style=&#34;color:#a6e22e&#34;&gt;isEqualTo&lt;/span&gt;(1);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  Executable divideByZero &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; () &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; calculator.&lt;span style=&#34;color:#a6e22e&#34;&gt;divide&lt;/span&gt;(4, 0);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  assertThrows(ArithmeticException.&lt;span style=&#34;color:#a6e22e&#34;&gt;class&lt;/span&gt;, divideByZero);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This test will both fail when calculator fails to divide correctly and when the error case of dividing by zero does not throw an &lt;code&gt;ArithmeticException&lt;/code&gt;. Therefore, in essence, we want to avoid a series of &lt;em&gt;act-assert&lt;/em&gt; sequences. A single act followed by more than one physical assertions is fine.&lt;/p&gt;
&lt;h3 id=&#34;assert-first&#34;&gt;
    &lt;a href=&#34;#assert-first&#34;&gt;#&lt;/a&gt;
    Assert first
&lt;/h3&gt;&lt;p&gt;&lt;em&gt;Assert first&lt;/em&gt; is a technique described in Kent Beck&amp;rsquo;s excellent book &lt;a class=&#34;link&#34; href=&#34;https://www.goodreads.com/book/show/387190.Test_Driven_Development&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Test Driven Development: By Example&lt;/a&gt;. As counterintuitive as it may sound (and feel for someone not used to it), it comes with tons of advantages and it will become second nature given some time. The main idea lies in the fact that writing a test presents multiple problems. The two principal ones are &lt;em&gt;&amp;ldquo;what is the right answer?&amp;rdquo;&lt;/em&gt; and &lt;em&gt;&amp;ldquo;how am I going to check it&amp;rdquo;&lt;/em&gt;. Taking this bottom up approach helps us focus on the target and avoid overengineering the test.&lt;/p&gt;
&lt;p&gt;Coming back to the arrange - act - assert example, assuming that I have a business requirement that a booking without booking ID is invalid, and I am writing the booking validator logic, I may start as follows:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@Test&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;validatorShouldThrowInvalidBookingExceptionWhenBookingIdIsNull&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  assertThrows(InvalidBookingException.&lt;span style=&#34;color:#a6e22e&#34;&gt;class&lt;/span&gt;, validateBooking);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Starting off with the &lt;em&gt;assert&lt;/em&gt;, I know both the right answer and how to check it. I am also driven to the proper act for my assertion.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@Test&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;validatorShouldThrowInvalidBookingExceptionWhenBookingIdIsNull&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  Executable validateBooking &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; () &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; validator.&lt;span style=&#34;color:#a6e22e&#34;&gt;validate&lt;/span&gt;(booking);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  assertThrows(InvalidBookingException.&lt;span style=&#34;color:#a6e22e&#34;&gt;class&lt;/span&gt;, validateBooking);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Now there is only one step missing, the arrange part. I need a booking and it should have a &lt;code&gt;null&lt;/code&gt; booking ID.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@Test&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;validatorShouldThrowInvalidBookingExceptionWhenBookingIdIsNull&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  Booking booking &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; BookingBuilder.&lt;span style=&#34;color:#a6e22e&#34;&gt;aBooking&lt;/span&gt;().&lt;span style=&#34;color:#a6e22e&#34;&gt;withBookingId&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;).&lt;span style=&#34;color:#a6e22e&#34;&gt;build&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  Executable validateBooking &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; () &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; validator.&lt;span style=&#34;color:#a6e22e&#34;&gt;validate&lt;/span&gt;(booking);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  assertThrows(InvalidBookingException.&lt;span style=&#34;color:#a6e22e&#34;&gt;class&lt;/span&gt;, validateBooking);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Writing a test in this bottom - up fashion seems strange initially, I know. My suggestion would be to give it a shot, stick with it passed the uncomfortable denial phase (the &lt;em&gt;&amp;ldquo;I want to write my tests like I&amp;rsquo;m used to&amp;rdquo;&lt;/em&gt; phase), and it will pay off.&lt;/p&gt;
&lt;h2 id=&#34;conclusion&#34;&gt;
    &lt;a href=&#34;#conclusion&#34;&gt;#&lt;/a&gt;
    Conclusion
&lt;/h2&gt;&lt;p&gt;I tried to share some knowledge and some techniques I use when writing unit tests, because I feel that the area is misunderstood. These are the most important topics I wanted to touch, but the list is far from exhaustive.&lt;/p&gt;
&lt;p&gt;Whichever the techniques we might use, let&amp;rsquo;s always keep in mind that tests are an integral part of the system and therefore they should be designed and maintained. We should care for them and we should take the time to write the &lt;em&gt;right tests&lt;/em&gt; in the &lt;em&gt;right way&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;P.S. I would also love to cover the whole &amp;ldquo;test state vs test behavior&amp;rdquo; topic, but this post is already lengthy enough and this is a really long topic&lt;/em&gt;&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
